package lock

import (
	"os"
	"path/filepath"

	"github.com/walteh/buf3pd/pkg/config"
	"gitlab.com/tozd/go/errors"
	"gopkg.in/yaml.v3"
)

// LockDepMetadata represents metadata for a dependency entry in the lock file
type LockDepMetadata struct {
	Commit string `yaml:"commit"`
	Type   string `yaml:"type"`
}

// Dep represents a dependency entry in the lock file
type Dep struct {
	Repo     string          `yaml:"repo"`
	Path     string          `yaml:"path"`
	Ref      string          `yaml:"ref"`
	Digest   string          `yaml:"digest"`
	Prefix   string          `yaml:"prefix"`
	Metadata LockDepMetadata `yaml:"metadata"`
}

// File represents the structure of the buf3pd.lock file
type File struct {
	Version string `yaml:"version"`
	Deps    []*Dep `yaml:"deps"`
}

// Manager provides an interface for managing lock files
type Manager interface {
	ReadLockFile(path string) (*File, error)
	WriteLockFile(file *File, path string) error
	EntryFor(file *File, dep config.Buf3pdDep) *Dep
}

// FileManager implements the Manager interface
type FileManager struct{}

// NewFileManager creates a new FileManager
func NewFileManager() *FileManager {
	return &FileManager{}
}

// ReadLockFile reads the lock file from the given path
func (m *FileManager) ReadLockFile(path string) (*File, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &File{
				Version: "v2",
				Deps:    []*Dep{},
			}, nil
		}
		return nil, errors.Errorf("reading lock file: %w", err)
	}

	var lockFile File
	if err := yaml.Unmarshal(content, &lockFile); err != nil {
		return nil, errors.Errorf("unmarshalling lock file: %w", err)
	}

	return &lockFile, nil
}

// WriteLockFile writes the lock file to the given path
func (m *FileManager) WriteLockFile(file *File, path string) error {
	lockFileContent, err := yaml.Marshal(file)
	if err != nil {
		return errors.Errorf("marshaling lock file: %w", err)
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return errors.Errorf("creating lock file directory: %w", err)
	}

	if err := os.WriteFile(path, []byte("# Generated by buf3pd. DO NOT EDIT.\n"+string(lockFileContent)), 0644); err != nil {
		return errors.Errorf("writing lock file: %w", err)
	}

	return nil
}

// EntryFor finds the lock entry for a given dependency
func (m *FileManager) EntryFor(file *File, dep config.Buf3pdDep) *Dep {
	for _, lockDep := range file.Deps {
		if lockDep.Repo == dep.Repo && lockDep.Path == dep.Path && lockDep.Ref == dep.Ref {
			return lockDep
		}
	}
	return nil
}

// Compare compares two lock entries
func (l *Dep) Compare(other *Dep) bool {
	return l.Repo == other.Repo &&
		l.Path == other.Path &&
		l.Ref == other.Ref &&
		l.Digest == other.Digest &&
		l.Prefix == other.Prefix
}
